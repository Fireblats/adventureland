(()=>{"use strict";var __webpack_exports__={};async function print(message){safe_log(message)}function get_item_quantity(item_name){if(item_name===null||item_name===undefined)return 0;let quantity=0;for(let i=0;i<character.items.length;i++){if(character.items[i]==null){break}if(character.items[i]!==undefined&&character.items[i].name===item_name){quantity+=character.items[i].q??0}}return quantity}function item_exists(item_name){for(let i=0;i<character.items.length;i++){if(character.items[i]==null){break}if(character.items[i].name===item_name){return true}}return false}async function customHPandMP(){if(character.hp<character.max_hp-200){use_skill("use_hp")}if(character.mp<character.max_mp-300||character.mp<20){use_skill("use_mp")}}function Test_Func(){print("Test_Func")}const characterID="Fireblats";safe_log("test2");const t1MageItems=[G.items.staff,G.items.helmet,G.items.shoes,G.items.gloves,G.items.coat];const t1RangerItems=[G.items.bow,G.items.helmet,G.items.shoes,G.items.gloves,G.items.coat];const t1WarriorItems=[G.items.blade,G.items.helmet,G.items.shoes,G.items.gloves,G.items.coat];const t1Mage2Items=[G.items.wbook0,G.items.helmet,G.items.shoes,G.items.gloves,G.items.coat];const delay=ms=>new Promise((res=>setTimeout(res,ms)));const customMonsters={Bee:{name:"Bee",x:496.78379392236116,y:1028.891401478082},Crab:{name:"Crab",x:-1181.7290115323442,y:-70.48519999365637}};const customCharacters={Lucas:{x:-460.9737110795928,y:-77.41004909360228},Gabriel:{x:-89.26400993247745,y:-143.6246820060477},Cue:{x:-207.37506379157145,y:-184.9999999,id:"newupgrade"},Ernis:{x:-39.864347750250225,y:-147.7134982894214}};const defaultSettings={attack_mode:true,attack_mode_fireblats:true,upgrading:false,currentMonster:customMonsters.Bee,minimumGoldToStopUpgrading:15e3,goldToStartUpgrading:15e4,upgrade_mode:false,currentUpgradeItem:G.items.staff,buyingPotions:false,maxHealthPotions:200,maxManaPotions:200,healthPotionName:"hpot0",manaPotionName:"mpot0",upgradeItem:G.items.staff,allItemsUpgraded:false,minimumScrollsToUpgrade:1,amountScrollsToBuy:30,doTeleportToTown:true};const defaultSettingsProxy=new Proxy(defaultSettings,{get:(o,property)=>{const propertyFromStorage=localStorage.getItem(property.toString()+characterID);return propertyFromStorage!==null?JSON.parse(propertyFromStorage):null},set:(o,property,value)=>{localStorage.setItem(property.toString()+characterID,JSON.stringify(value));if(property===`upgrade_mode${characterID}`&&value===false){defaultSettingsProxy.doTeleportToTown=true}return true}});function sleep(ms){return new Promise((resolve=>setTimeout(resolve,ms)))}async function teleportToTown(){safe_log("Waiting 5 seconds for teleport...");await use_skill("use_town").then((async()=>{safe_log("Teleported to town")}),(async()=>{safe_log("Failed to teleport to town")}));await delay(5e3)}async function teleportIfWeNeedTo(){if(character.map==="main"&&Math.abs(character.x)<500&&Math.abs(character.y)<500){await teleportToTown()}}async function checkHealthPotions(){if(quantity("hpot0")<10||quantity("mpot0")<10){const hpot0Price=G.items.hpot0.g;const mpot0Price=G.items.mpot0.g;const currentHealthPotions=quantity("hpot0");const currentManaPotions=quantity("mpot0");const{maxHealthPotions}=defaultSettingsProxy;const{maxManaPotions}=defaultSettingsProxy;const{gold}=character;const goldNeeded=(maxHealthPotions-currentHealthPotions)*hpot0Price+(maxManaPotions-currentManaPotions)*mpot0Price;if(gold>=goldNeeded){defaultSettingsProxy.buyingPotions=true}}else{defaultSettingsProxy.buyingPotions=false}if(defaultSettingsProxy.buyingPotions){safe_log("Potions are making us teleport to town.");await teleportIfWeNeedTo();safe_log(`defaultSettingsProxy.buyingPotions: ${defaultSettingsProxy.buyingPotions}`);safe_log("Buying potions...");if(!smart.moving){smart_move({x:customCharacters.Ernis.x,y:customCharacters.Ernis.y})}await delay(1e3);while(smart.moving){await delay(1e3)}buy("hpot0",defaultSettingsProxy.maxHealthPotions-quantity("hpot0"));buy("mpot0",defaultSettingsProxy.maxManaPotions-quantity("mpot0"))}}function getMiddleOfBoundary(boundary){const x1=boundary[0];const y1=boundary[1];const x2=boundary[2];const y2=boundary[3];const mid_x=(x1+x2)/2;const mid_y=(y1+y2)/2;return[mid_x,mid_y]}function chooseMonster(){const growList={};let monsterPosition=[0,0];if(G.maps.main.monsters){for(const monster of G.maps.main.monsters){if(monster.grow){monsterPosition=getMiddleOfBoundary(monster.boundary?monster.boundary:[0,0,0,0]);if(monster!==undefined){growList[monster.type]=monsterPosition}}}}for(const key of Object.keys(growList)){const monsterKey=key;if(!growList[monsterKey])continue}const max2ShotHealth=character.attack*2;let bestMob="goo";let bestMobHealth=G.monsters.goo.hp;for(const key of Object.keys(growList)){const monsterKey=key;if(!growList[monsterKey])continue;const monsterHealth=G.monsters[monsterKey].hp;if(monsterHealth<max2ShotHealth&&monsterHealth>bestMobHealth){bestMob=monsterKey;bestMobHealth=monsterHealth;if(!customMonsters[bestMob]){customMonsters[bestMob]={name:bestMob,x:growList[key]?.[0]??0,y:growList[key]?.[1]??0}}}}defaultSettingsProxy.currentMonster=customMonsters[bestMob]}async function battleMonsters(monster){if(character.id==="Fireblats"){chooseMonster();monster=customMonsters[defaultSettingsProxy.currentMonster.name]}if(character.id==="FireblatsW"){const charX=Math.abs(character.x);const charY=Math.abs(character.y);if(Math.abs(charX-Math.abs(monster.x))>150||Math.abs(charY-Math.abs(monster.y))>150){safe_log(`Distance to monster.x: ${Math.abs(charX-Math.abs(monster.x))}`);safe_log(`Distance to monster.y: ${Math.abs(charY-Math.abs(monster.y))}`);if(!smart.moving){safe_log("to far away, moving to monster");await smart_move({x:monster.x,y:monster.y})}}}else{if(character.real_x!==monster.x||character.real_y!==monster.y){if(!smart.moving){await smart_move({x:monster.x,y:monster.y})}}}let target=get_targeted_monster();if(!target){target=get_nearest_monster({min_xp:100,max_att:120});if(target){change_target(target)}else{set_message("No Monsters");return}}if(character.id==="FireblatsW"){if(!is_in_range(target,"attack")){await move(character.x+(target.x-character.x),character.y+(target.y-character.y))}else if(can_attack(target)){set_message("Attacking");attack(target)}}else{if(!is_in_range(target)){await move(character.x+(target.x-character.x)/2,character.y+(target.y-character.y)/2)}else if(can_attack(target)){set_message("Attacking");attack(target)}}}async function chooseUpgradeItem(){let characterSet=null;if(character.id==="Fireblats"){characterSet=t1MageItems}else if(character.id==="FireblatsR"){characterSet=t1RangerItems}else if(character.id==="FireblatsW"){characterSet=t1WarriorItems}if(characterSet===null){characterSet=t1MageItems}for(const[,value]of Object.entries(characterSet)){const itemName=value.id;const searchItem=character.items.filter((item=>item!==null&&item!==undefined&&item.name===itemName&&item.level!==undefined&&item.level>=7));if(searchItem.length>0){safe_log(`Found Found T${searchItem[0].level} ${itemName} in bag`);continue}for(const[key1,value1]of Object.entries(character.slots)){if(value1!==null&&value1!==undefined&&value1.name===itemName&&value1.level!==undefined&&value1.level>=7){safe_log(`Found T${value1.level} ${itemName} in slot key1: ${key1}, value1.name: ${value1.name}`);if(key1==="shoes"&&value1.level>=7)return false;continue}}safe_log(`Couldn't find [T7+ ${itemName}], choosing for upgrading`);if(value!==undefined)defaultSettingsProxy.upgradeItem=value;return true}}async function needScrolls(){if(locate_item("scroll0")===-1){safe_log(`We don't have any scrolls.`);return-1}const scrolls=character.items.filter((item=>item!==null&&item!==undefined&&item.name==="scroll0"&&item.q!==undefined&&item.q>0));let q=0;for(const[,value]of Object.entries(scrolls)){q+=value.q?value.q:0}if(q<defaultSettingsProxy.minimumScrollsToUpgrade)return q;return false}async function buyScrolls(currentScrollQuantity){safe_log(`Scrolls made us teleport to town.`);await teleportIfWeNeedTo();safe_log("Buying scrolls...");if(!smart.moving){await smart_move({x:customCharacters.Lucas.x,y:customCharacters.Lucas.y})}const pricePerScroll=G.items.scroll0.g;const goldNeeded=(defaultSettingsProxy.amountScrollsToBuy-currentScrollQuantity)*pricePerScroll;if(character.gold<goldNeeded){safe_log(`Not enough gold to buy scrolls. Needed: ${goldNeeded}, Have: ${character.gold}`);defaultSettingsProxy.upgrade_mode=false}else{buy("scroll0",defaultSettingsProxy.amountScrollsToBuy-currentScrollQuantity);safe_log(`Bought ${defaultSettingsProxy.amountScrollsToBuy-currentScrollQuantity} scrolls for ${goldNeeded} gold`)}}async function walkToUpgradeNpc(){if(!smart.moving){await smart_move({x:customCharacters.Cue.x,y:customCharacters.Cue.y})}}async function upgradeItem(){safe_log(`Upgrading ${defaultSettingsProxy.upgradeItem.id}`);const itemToUpgrade=locate_item(defaultSettingsProxy.upgradeItem.id);const scrollItem=locate_item("scroll0");const success=await upgrade(itemToUpgrade,scrollItem);if(success){safe_log(`Upgraded ${defaultSettingsProxy.upgradeItem.id} successfully`)}else{safe_log(`Failed to upgrade ${defaultSettingsProxy.upgradeItem.id}, item is lost.`)}}async function doNeedItemForUpgrade(){for(const[key,value]of Object.entries(character.items)){if(value!==null&&value!==undefined&&value.name===defaultSettingsProxy.upgradeItem.id){safe_log(`Found ${defaultSettingsProxy.upgradeItem.id} in slot ${key}`);return false}}return true}async function buyItemForUpgrade(){if(!smart.moving){await smart_move({x:customCharacters.Gabriel.x,y:customCharacters.Gabriel.y})}await buy(defaultSettingsProxy.upgradeItem.id,1)}async function equipHighestLevelItem(){const staffInventoryPosition=locate_item(defaultSettingsProxy.upgradeItem.id);let inventoryStaffLevel;let equipmentStaffSlot=null;let equipmentStaffLevel=0;if(staffInventoryPosition!==undefined&&staffInventoryPosition!==null&&staffInventoryPosition!==-1){inventoryStaffLevel=character.items[staffInventoryPosition].level}else{return}for(const[key,value]of Object.entries(character.slots)){if(value!==null&&value!==undefined&&value.name===defaultSettingsProxy.upgradeItem.id){equipmentStaffSlot=key;equipmentStaffLevel=value.level;break}}if(equipmentStaffSlot===undefined||equipmentStaffSlot===null)return;if(inventoryStaffLevel>equipmentStaffLevel){equip(staffInventoryPosition,equipmentStaffSlot);safe_log(`Equipped ${defaultSettingsProxy.upgradeItem.id} from inventory`)}}async function upgradeItems(){if(defaultSettingsProxy.allItemsUpgraded){safe_log(`Current allItemsUpgraded: ${defaultSettingsProxy.allItemsUpgraded}`);safe_log("All items upgraded, returning");return}if(character.gold>defaultSettingsProxy.goldToStartUpgrading){safe_log(`Current gold: ${character.gold}, starting upgrade mode and stopping attack mode`);defaultSettingsProxy.upgrade_mode=true;defaultSettingsProxy.attack_mode=false}if(character.gold<defaultSettingsProxy.minimumGoldToStopUpgrading){safe_log(`Current gold: ${character.gold}, stopping upgrade mode and starting attack mode`);defaultSettingsProxy.upgrade_mode=false;defaultSettingsProxy.attack_mode=true;return}if(!defaultSettingsProxy.upgrade_mode)return;if(!chooseUpgradeItem()){defaultSettingsProxy.allItemsUpgraded=true;defaultSettingsProxy.upgrade_mode=false;safe_log("All items upgraded, returning");return}safe_log(`upgrading item: ${defaultSettingsProxy.upgradeItem.id}`);if(defaultSettingsProxy.doTeleportToTown===true){await teleportIfWeNeedTo();defaultSettingsProxy.doTeleportToTown=false}const currentScrolls=await needScrolls();const needItemForUpgrade=await doNeedItemForUpgrade();if(currentScrolls){await buyScrolls(currentScrolls)}if(needItemForUpgrade){safe_log(`We don't have ${defaultSettingsProxy.upgradeItem.id}, going to buy it.`);if(defaultSettingsProxy.upgradeItem.id!==undefined&&character.gold<G.items[defaultSettingsProxy.upgradeItem.id].g){safe_log(`We don't have enough gold to buy ${defaultSettingsProxy.upgradeItem.id},\n             killing monsters to get gold.`);defaultSettingsProxy.upgrade_mode=false;defaultSettingsProxy.attack_mode=true;return}await buyItemForUpgrade()}await equipHighestLevelItem();if(!defaultSettingsProxy.upgrade_mode)return;if(character.gold<defaultSettingsProxy.minimumGoldToStopUpgrading){defaultSettingsProxy.upgrade_mode=false;defaultSettingsProxy.attack_mode=true;return}safe_log(`Walking to upgrade NPC`);await walkToUpgradeNpc();await upgradeItem();await upgradeItems()}async function mainLoop(){await customHPandMP();loot();await checkHealthPotions();await upgradeItems();await battleMonsters(defaultSettingsProxy.currentMonster);setTimeout(mainLoop,1e3/4)}mainLoop();if(character.id==="FireblatsW"||"mage"==="warrior"){mainLoop()}else{safe_log("test")}})();